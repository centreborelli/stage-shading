import numpy as np
# import pylab as plt
import os
path = 'C:/Users/dugas/Desktop/sauvegarde/stage-shading/src/modules python'
os.chdir(path)
import fonctions_FMM as fm
import fonctions_calculs as fc
import fonctions_espace as fe
import fonctions_lissage as fl
import copy as c
import scipy.spatial as scp
import os
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from scipy.linalg import norm
from scipy.linalg import solve


# plt.ion()
# plt.show()


## Algo :

## Initialisation du relief et des autres tableaux

h=1/100
X,Y = np.meshgrid(np.arange(0,1,h),np.arange(0,1,h),indexing='ij')
height = fe.ThreeBumps(X,Y)
# height = height[0:70,0:70]
(n,m) = height.shape
# height = fl.lisse_conv(height)
# # CAS = np.zeros((n,m))
#
# n = 100
# m = 100

"""pont"""
# #
# def Pont(x,y) :
#     a=8
#     p = 1-a*(x-0.5)**2
#     return (p>0)*(y>=0.4)*(y<=0.6)*p
#
# h=1/100
# X,Y = np.meshgrid(np.arange(0,1,h),np.arange(0,1,h),indexing='ij')
# height = Pont(X,Y)
# masque = np.ones((100,100))
# masque[15:86,39] *= 3
# masque[15:86,40] *= 7
# masque[15:86,60] *= 3
# masque[15:86,61] *= 7


"""gaussienne - plan discontinue"""
# X,Y = np.meshgrid(np.arange(0,1,2*h),np.arange(0,1,h),indexing='ij')
#
# height = np.zeros((n,m))
# A = np.ones((n//2,m))
# height[0:(n//2),:] = 2*A
#
# A = fe.gaussienne_x(X,Y)
# height[n//2:,:] = A
# #
# #
# # masque = np.ones((n,m))
# # for j in range(m) :
# #     masque[n//2-1,j] *= 5
# #     masque[(n//2),j] *= 2
#
# #
# height[:,0] = 2
# height[:,m-1] = 2
#
#
# masque = np.ones((n,m))
# masque[n//2-1,1:m-1] *= 5
# masque[n//2,1:m-1] *=2
#
# masque[n//2:,0] *= 3
# masque[n//2:,m-1] *= 7
# masque[n//2:,1] *= 7
# masque[n//2:,m-2] *= 3



# #
masque_prio = np.ones((n,m))
# masque_prio[n//2:,1:m-1] = 2
#
masque_cond = np.zeros((n,m))
# masque_cond[n//2:,1] = 2 - fe.gaussienne_x(X[:,-1],Y[:,-1])
# masque_cond[n//2:,m-2] = 2-fe.gaussienne_x(X[:,-1],Y[:,-1])
# masque_cond[n//2,1:m-1] = 2



'''threebumps discontinues'''
# #
# A = fe.ThreeBumps(X,Y)
#
# def bump1(x,y) :
#     return(0.3-3*((x-0.4)**2+(y-0.5)**2))
# def bump2(x,y) :
#     return(0.25-3*((x-0.65)**2+(y-0.6)**2))
# def bump3(x,y):
#     return(0.25-3*((x-0.6)**2+(y-0.35)**2))
#
# n,m = A.shape
# A = bump1(X,Y)
# B= bump2(X,Y)
# C = bump3(X,Y)
# U = np.ones((n,m))
# V = np.ones((n,m))
#
# W = np.ones((n,m))
#
#
# for i in range(n) :
#     for j in range(m) :
#         if np.abs(A[i,j] - B[i,j]) < 10**-2 :
#             U[i,j] *= 2
#             U[i-1,j] *=5
#         if np.abs(B[i,j] - C[i,j]) < 10**-2 :
#             V[i,j] *= 3
#             V[i,j+1]*= 7
#         if np.abs(A[i,j] - C[i,j]) < 10**-2 :
#             W[i,j] *= 2
#             W[i-1,j] *= 5
#         if U[i,j] != 1 and V[i,j] != 1 :
#             a,b = i,j
# D = np.zeros((n,m))
# for i in range(n) :
#     for j in range(m) :
#         if j> b :
#             W[i,j]  = 1
#         else : U[i,j] = 1
#         if i < a :
#             V[i,j] = 1
#
# D = np.zeros((n,m))
# for i in range(n) :
#     for j in range(m) :
#         D[i,j] = max(U[i,j],V[i,j],W[i,j])
#
# A = fe.ThreeBumps(X,Y)
# for i in range(n) :
#     for j in range(m) :
#         if A[i,j] == 0 :
#             D[i,j] = 1
#
# masque = D


Etats = np.ones((n,m)) # 0 = Far ; 1 = Trial ; 2 = Accepted
Etats[1:-1,1:-1] = np.zeros((n-2,m-2))
Etats[n-1,:] = 0
Etats[:,m-1] = 0
# Etats[a,b] = 1
Bord = Etats == 1

U = np.zeros((n,m)) # valeur de la fonction
U[:,:] = height
U[1:-1,1:-1] = np.inf*np.ones((n-2,m-2))
U[n-1,:] = np.inf
U[:,m-1] = np.inf
# U[a,b] = fe.ThreeBumps(X[a,b],Y[a,b])
V = np.zeros((n,m)) # Valeurs des trials
V[1:-1,1:-1] = np.inf*np.ones((n-2,m-2))
V[0,:],V[:,0],V[n-1,:],V[:,m-1] = U[0,:],U[:,0],U[n-1,:],U[:,m-1]
V[n-1,:] = np.inf
V[:,m-1] = np.inf
# V[a,b] = fe.ThreeBumps(X[a,b],Y[a,b])
# X = np.arange(0, n, 1)
# Y = np.arange(0, m, 1)
# X, Y = np.meshgrid(X, Y)


## Choix de la lumière et récupération de l'intensité

# Shading parameters

α,β,γ= fe.parametres(0,90)


params = α,β,γ,h


I = fe.GenerateRHS_discontinue(height,masque,params)


# I,Omega = fe.GenerateIntDiscont(height,params)


# I,Omega = fe.GenerateRHS(height,params)
#

# I0 = fe.IntInit(I,params)
#
# Utot = []
# for i in range(10) :
#
#     Etats = np.ones((n,m)) # 0 = Far ; 1 = Trial ; 2 = Accepted
#     Etats[1:-1,1:-1] = np.zeros((n-2,m-2))
#     Bord = Etats == 1
#
#     T = np.zeros((n,m)) # valeur de la fonction
#     T[:,:] = U
#     T[1:-1,1:-1] = np.inf*np.ones((n-2,m-2))
#     V = np.zeros((n,m)) # Valeurs des trials
#     V[1:-1,1:-1] = np.inf*np.ones((n-2,m-2))
#     V[0,:],V[:,0],V[n-1,:],V[:,m-1] = U[0,:],U[:,0],U[n-1,:],U[:,m-1]
#
#
#     params0 = 0,0,1,h
#     [U] = fm.FMM(Etats, V, T, I0, Bord, params0, fc.solve_quad)
#
#     Utot.append(U)
#
#     I0 = fe.GenerateIntIter(U,I,params)
#

## FAST MARCHING

# [U,CAS,ITERATION,DELTA] = fm.FFM(Etats, V, U, I, Bord, params, fc.solve_quad, Cas=True,iterations=True, Delta=True)
# [U,CAS,ITERATION,DELTA] = fm.FFM_strict(Etats, V, U, I, Bord, params, fc.solve_quad, Cas=True,iterations=True, Delta=True)
[U,ITERATION] = fm.FMM_discontinue(Etats, V, U, I, Bord, params, fc.solve_quad,masque,masque_prio,masque_cond, iterations=True)


# [V,ITERATION,DELTA] = fm.FMM(Etats, V, U, I, Bord, params, fc.solve_quad,iterations = True,Delta = True)
# [U,CAS,ITERATION] = fm.FFM_var(Etats, V, U, I, Bord, params, fc.solve_quad2, fc.variation_per, Cas=True,iterations=True)

## EXPLOITATION DES RESULTATS


def affiche(L,U,i) :
    if 1 in L :
        plt.figure("Relief original"+str(i))
        plt.clf()
        plt.imshow(height,cmap="terrain")
        plt.colorbar()
    if 2 in L :
        plt.figure("Intensité originale"+str(i))
        plt.clf()
        plt.imshow(I,cmap='gray')
        plt.colorbar()
    if 3 in L :
        plt.figure("Relief reconstitué"+str(i))
        plt.clf()
        plt.imshow(U,cmap="terrain")
        plt.colorbar()
    if 4 in L :
        I2 = fe.GenerateRHS_discontinue(U,masque,params)
        # I2,Omega = fe.GenerateRHS(U,params)
        plt.figure("Nouvelle intensité"+str(i))
        plt.clf()
        plt.imshow(I2,cmap='gray')
        plt.colorbar()
    if 5 in L :
        plt.figure("Ecart de relief"+str(i))
        plt.clf()
        plt.imshow(height-U,cmap=plt.cm.RdBu_r,vmin = -0.05,vmax = 0.05)
        plt.colorbar()
    if 6 in L :
        fig,ax = plt.subplots(subplot_kw = {"projection":"3d"})
        surf = ax.plot_surface(X,Y,U,cmap = cm.coolwarm,linewidth = 0,antialiased = False)
        fig.colorbar(surf,shrink = 0.5,aspect = 5)
    if 7 in L :
        plt.figure("Voisins considérés pour les calculs"+str(i))
        plt.clf()
        plt.imshow(CAS,cmap=plt.cm.RdBu_r)
    if 8 in L :
        plt.figure("Itérations"+str(i))
        plt.clf()
        plt.imshow(ITERATION)
    if 9 in L :
        plt.figure("Deltas négatifs ?"+str(i))
        plt.clf()
        plt.imshow(DELTA)
        plt.colorbar()
    if 10 in L :
        print(np.sum(np.abs(U-height))*h**2)
    plt.show()

#
# W = fl.lisse_conv(V)
#
# U = fl.lisse_moy(V)
# affiche([4,6],U,1)
# affiche([4,6],V,2)
# affiche([4,6],fl.lisse_med(V),3)
# affiche([4,6],W,4)
# # affiche([4,6],fl.liss_dev2(V),3)
# affiche([4,6],fl.lisse_conv_gauss(V),3)
# # # plt.show()













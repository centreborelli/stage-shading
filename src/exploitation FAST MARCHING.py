import numpy as np
# import pylab as plt
import os
path = 'C:/Users/dugas/Documents/stage-shading/src/modules python'
os.chdir(path)
import fonctions_FMM as fm
import fonctions_calculs as fc
import fonctions_espace as fe
import fonctions_lissage as fl
import copy as c
import scipy.spatial as scp
import os
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from scipy.linalg import norm
from scipy.linalg import solve


# plt.ion()
plt.show()


## Algo :

## Initialisation du relief et des autres tableaux

h=1/100
X,Y = np.meshgrid(np.arange(0,1,h),np.arange(0,1,h),indexing='ij')
height = fe.ThreeBumps(X,Y)
(n,m) = height.shape
# CAS = np.zeros((n,m))

n = 100
m = 100
#
# height = np.zeros((n,m))
# A = np.ones((n//2,m))
# height[0:(n//2),:] = A
#
# masque = np.zeros((n,m))
# for j in range(m) :
#     masque[n//2-1,j] = 3
#     masque[(n//2),j] = 1

# height=np.zeros((n,m))
"""On impose zéro aux bords du rectangle, et on résoud SFS avec le fast marching en partant du bord"""

Etats = np.ones((n,m)) # 0 = Far ; 1 = Trial ; 2 = Accepted
Etats[1:-1,1:-1] = np.zeros((n-2,m-2))
Bord = Etats == 1

U = np.zeros((n,m)) # valeur de la fonction
U[:,:] = height
U[1:-1,1:-1] = np.inf*np.ones((n-2,m-2))
V = np.zeros((n,m)) # Valeurs des trials
V[1:-1,1:-1] = np.inf*np.ones((n-2,m-2))
V[0,:],V[:,0],V[n-1,:],V[:,m-1] = U[0,:],U[:,0],U[n-1,:],U[:,m-1]

# On peut aussi imposer zéro aux bords du relief et commencer la FMM sur ce bord en utililsant la ligne suivante
# U,V,Etats = Initialise_contour(height,0)

X = np.arange(0, n, 1)
Y = np.arange(0, m, 1)
X, Y = np.meshgrid(X, Y)


## Choix de la lumière et récupération de l'intensité

# Shading parameters

α,β,γ= fe.parametres(0,90)


params = α,β,γ,h
# I,Omega = fe.GenerateIntDiscont(height,params)


I,Omega = fe.GenerateRHS(height,params)

I0 = fe.IntInit(I,params)

Utot = []
for i in range(50) :

    Etats = np.ones((n,m)) # 0 = Far ; 1 = Trial ; 2 = Accepted
    Etats[1:-1,1:-1] = np.zeros((n-2,m-2))
    Bord = Etats == 1

    T = np.zeros((n,m)) # valeur de la fonction
    T[:,:] = U
    T[1:-1,1:-1] = np.inf*np.ones((n-2,m-2))
    V = np.zeros((n,m)) # Valeurs des trials
    V[1:-1,1:-1] = np.inf*np.ones((n-2,m-2))
    V[0,:],V[:,0],V[n-1,:],V[:,m-1] = U[0,:],U[:,0],U[n-1,:],U[:,m-1]


    params0 = 0,0,1,h
    [U] = fm.FMM(Etats, V, T, I0, Bord, params0, fc.solve_quad)

    Utot.append(U)

    I0 = fe.GenerateIntIter(U,I,params)


## FAST MARCHING

# [U,CAS,ITERATION,DELTA] = fm.FFM(Etats, V, U, I, Bord, params, fc.solve_quad, Cas=True,iterations=True, Delta=True)
# [U,CAS,ITERATION,DELTA] = fm.FFM_strict(Etats, V, U, I, Bord, params, fc.solve_quad, Cas=True,iterations=True, Delta=True)
# [U,ITERATION] = fm.FMM_discontinue(Etats, V, U, I, Bord, params, fc.solve_quad,masque,iterations=True)
[V] = fm.FMM(Etats, V, U, I, Bord, params, fc.solve_quad)
# [U,CAS,ITERATION] = fm.FFM_var(Etats, V, U, I, Bord, params, fc.solve_quad2, fc.variation_per, Cas=True,iterations=True)

## EXPLOITATION DES RESULTATS


def affiche(L,U,i) :
    if 1 in L :
        plt.figure("Relief original"+str(i))
        plt.clf()
        plt.imshow(height,cmap=plt.cm.RdBu_r)
        plt.colorbar()
    if 2 in L :
        plt.figure("Intensité originale"+str(i))
        plt.clf()
        plt.imshow(I,cmap='gray')
        plt.colorbar()
    if 3 in L :
        plt.figure("Relief reconstitué"+str(i))
        plt.clf()
        plt.imshow(U,cmap=plt.cm.RdBu_r)
        plt.colorbar()
    if 4 in L :
        I2,Omega = fe.GenerateRHS(U,params)
        plt.figure("Nouvelle intensité"+str(i))
        plt.clf()
        plt.imshow(I2,cmap='gray')
        plt.colorbar()
    if 5 in L :
        plt.figure("Ecart de relief"+str(i))
        plt.clf()
        plt.imshow(height-U,cmap=plt.cm.RdBu_r)
        plt.colorbar()
    if 6 in L :
        fig,ax = plt.subplots(subplot_kw = {"projection":"3d"})
        surf = ax.plot_surface(X,Y,U,cmap = cm.coolwarm,linewidth = 0,antialiased = False)
        fig.colorbar(surf,shrink = 0.5,aspect = 5)
    if 7 in L :
        plt.figure("Voisins considérés pour les calculs"+str(i))
        plt.clf()
        plt.imshow(CAS,cmap=plt.cm.RdBu_r)
    if 8 in L :
        plt.figure("Itérations"+str(i))
        plt.clf()
        plt.imshow(ITERATION)
    if 9 in L :
        plt.figure("Deltas négatifs ?"+str(i))
        plt.clf()
        plt.imshow(DELTA)
        plt.colorbar()
    if 10 in L :
        print(np.sum(np.abs(U-height))*h**2)
    plt.show()



# U = fl.lisse_moy(V)
# affiche([4,6],U,1)
# affiche([4,6],V,2)
# affiche([4,6],fl.lisse_med(V),3)
# affiche([4,6],W,4)
# affiche([4,6],fl.liss_dev2(V),3)
# affiche([4,6],fl.lisse_conv_gauss(V),3)
# # plt.show()













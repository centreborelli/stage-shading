import numpy as np
import pylab as plt
import os
path = 'D:/L3/Stage/modules python'
os.chdir(path)
import fonctions_FMM as fm
import fonctions_calculs as fc
import fonctions_espace as fe

plt.ion()
plt.show()


## Algo :

## Initialisation du relief et des autres tableaux

# Err = []
# H = []

# print(k)
h=1/100
# h = 1.5**(-k)
# H.append(h)
X,Y = np.meshgrid(np.arange(0,1,h),np.arange(0,1,h),indexing='ij')
height = fe.OneBump(X,Y)
(n,m) = height.shape
CAS = np.zeros((n,m))

height=np.zeros((n,m))
"""On impose zéro aux bords du rectangle, et on résoud SFS avec le fast marching en partant du bord"""

Etats = np.ones((n,m)) # 0 = Far ; 1 = Trial ; 2 = Accepted
Etats[1:-1,1:-1] = np.zeros((n-2,m-2))
Bord = Etats == 1

U = np.zeros((n,m)) # valeur de la fonction
U[:,:] = height
U[1:-1,1:-1] = np.inf*np.ones((n-2,m-2))
V = np.zeros((n,m)) # Valeurs des trials
V[1:-1,1:-1] = np.inf*np.ones((n-2,m-2))

# On peut aussi imposer zéro aux bords du relief et commencer la FMM sur ce bord en utililsant la ligne suivante
# U,V,Etats = Initialise_contour(height,0)

X = np.arange(0, n, 1)
Y = np.arange(0, m, 1)
X, Y = np.meshgrid(X, Y)


## Choix de la lumière et récupération de l'intensité (lignes issues du Jupyter)

# Shading parameters

# ω = 0.8*np.array([1,np.pi]) # c'est sur le réel devant le tableau qu'il faut jouer pour obtenir des images convainquantes (il détermine le poids des composantes en x et y  par rapport à celle en z).
# α,β,γ = np.append(ω,1)/np.linalg.norm(np.append(ω,1))


α,β,γ= fe.parametres(0,60)


params = α,β,γ,h
I,Omega = fe.GenerateRHS(height,params)

## FAST MARCHING

[U,CAS,ITERATION] = fm.FFM(Etats, V, U, I, Bord, params, fc.solve_quad2, fc.variation_per, cas=True,iterations=True)

## EXPLOITATION DES RESULTATS


# print(abs(np.sum(U)-np.sum(height))*h**2)


# H = np.array(H)
# Err = np.array(Err)
# [A,B] = np.polyfit(np.log10(H),np.log10(Err),1)
# Reg = H**A*10**B
# plt.figure(10)
# plt.clf()
# plt.loglog(H,Err,'o')
# plt.loglog(H,Reg)




# seuil = np.max(height)
# B2 = U>seuil
# U2 = np.zeros_like(U)
# U2[:,:] = U
# U2[B2] = seuil

from matplotlib import cm
# fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
# surf = ax.plot_surface(X, Y, height, cmap=cm.coolwarm,linewidth=0, antialiased=False)
# fig.colorbar(surf, shrink=0.5, aspect=5)

plt.figure(1)
plt.clf()
plt.imshow(height,cmap=plt.cm.RdBu_r)
plt.colorbar()

# plt.figure(2)
# plt.clf()
# plt.imshow(I,cmap='gray')
# plt.colorbar()


# fig2, ax2 = plt.subplots(subplot_kw={"projection": "3d"})
# surf2 = ax2.plot_surface(X, Y, U, cmap=cm.coolwarm,linewidth=0, antialiased=False)
# fig2.colorbar(surf2, shrink=0.5, aspect=5)

plt.figure(3)
plt.clf()
plt.imshow(U,cmap=plt.cm.RdBu_r)
plt.colorbar()
#
# I2,Omega = GenerateRHS(U,params)
# plt.figure(4)
# plt.clf()
# plt.imshow(I2,cmap='gray')
# plt.colorbar()

plt.figure(7)
plt.clf()
plt.imshow(CAS,cmap=plt.cm.RdBu_r)
plt.figure(8)
plt.clf()
plt.imshow(height-U,cmap=plt.cm.RdBu_r)
plt.colorbar()



plt.show()



import numpy as np
import pylab as plt
import os
path = 'D:/L3/Stage/modules python'
os.chdir(path)
import fonctions_FMM as fm
import fonctions_calculs as fc
import fonctions_espace as fe

plt.ion()
plt.show()


## Algo :

## Initialisation du relief et des autres tableaux

# Err = []
# H = []

# print(k)
h=1/100
# h = 1.5**(-k)
# H.append(h)
X,Y = np.meshgrid(np.arange(0,1,h),np.arange(0,1,h),indexing='ij')
height = fe.OneBump(X,Y)
(n,m) = height.shape
CAS = np.zeros((n,m))



# height=np.zeros((n,m))
"""On impose zéro aux bords du rectangle, et on résoud SFS avec le fast marching en partant du bord"""

Etats = np.ones((n,m)) # 0 = Far ; 1 = Trial ; 2 = Accepted
Etats[1:-1,1:-1] = np.zeros((n-2,m-2))
Bord = Etats == 1

U = np.zeros((n,m)) # valeur de la fonction
U[:,:] = height
U[1:-1,1:-1] = np.inf*np.ones((n-2,m-2))
V = np.zeros((n,m)) # Valeurs des trials
V[1:-1,1:-1] = np.inf*np.ones((n-2,m-2))

# On peut aussi imposer zéro aux bords du relief et commencer la FMM sur ce bord en utililsant la ligne suivante
# U,V,Etats = Initialise_contour(height,0)

X = np.arange(0, n, 1)
Y = np.arange(0, m, 1)
X, Y = np.meshgrid(X, Y)


## Choix de la lumière et récupération de l'intensité (lignes issues du Jupyter)

# Shading parameters

# ω = 0.8*np.array([1,np.pi]) # c'est sur le réel devant le tableau qu'il faut jouer pour obtenir des images convainquantes (il détermine le poids des composantes en x et y  par rapport à celle en z).
# α,β,γ = np.append(ω,1)/np.linalg.norm(np.append(ω,1))


α,β,γ= fe.parametres(40,80)


params = α,β,γ,h
I,Omega = fe.GenerateRHS(height,params)

## FAST MARCHING

[U,CAS,ITERATION] = fm.FFM(Etats, V, U, I, Bord, params, fc.solve_quad, cas=True,iterations=True)


# [U,CAS,ITERATION] = fm.FFM_var(Etats, V, U, I, Bord, params, fc.solve_quad2, fc.variation_per, cas=True,iterations=True)

## EXPLOITATION DES RESULTATS
from matplotlib import cm

def affiche(L) :
    if 1 in L :
        plt.figure("Relief originale")
        plt.clf()
        plt.imshow(height,cmap=plt.cm.RdBu_r)
        plt.colorbar()
    if 2 in L :
        plt.figure("Intensité originale")
        plt.clf()
        plt.imshow(I,cmap='gray')
        plt.colorbar()
    if 3 in L :
        plt.figure("Relief reconstitué")
        plt.clf()
        plt.imshow(U,cmap=plt.cm.RdBu_r)
        plt.colorbar()
    if 4 in L :
        I2,Omega = fe.GenerateRHS(U,params)
        plt.figure("Nouvelle intensité")
        plt.clf()
        plt.imshow(I2,cmap='gray')
        plt.colorbar()
    if 5 in L :
        plt.figure("Voisins considérés pour les calculs")
        plt.clf()
        plt.imshow(CAS,cmap=plt.cm.RdBu_r)
    if 6 in L :
        plt.figure("Ecart de relief")
        plt.clf()
        plt.imshow(height-U,cmap=plt.cm.RdBu_r)
        plt.colorbar()
    if 7 in L :
        plt.figure("Itérations")
        plt.clf()
        plt.imshow(ITERATION)
    plt.show()





